#!/usr/bin/env tsx

/**
 * Script para refrescar/actualizar blogs SEO antiguos
 * Ejecutado por Replit Scheduled Deployment semanalmente
 * 
 * Configuración recomendada:
 * - Hora: Domingos a las 10:00 AM
 * - Zona horaria: America/Panama
 * - Cron: 0 10 * * 0
 * - Timeout: 300 segundos
 * 
 * Uso: tsx scripts/refresh-old-blogs.ts
 */

import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool, neonConfig } from '@neondatabase/serverless';
import { eq, asc, and, lt } from 'drizzle-orm';
import ws from 'ws';
import * as schema from '../shared/schema.js';

neonConfig.webSocketConstructor = ws;

interface LogEntry {
  timestamp: string;
  level: 'INFO' | 'WARN' | 'ERROR' | 'DEBUG';
  event: string;
  data?: Record<string, unknown>;
}

const BLOGS_TO_REFRESH = 2;
const MIN_AGE_DAYS = 30;

function log(entry: LogEntry): void {
  console.log(JSON.stringify({
    ...entry,
    timestamp: entry.timestamp || new Date().toISOString(),
  }));
}

function generateBatchId(): string {
  const date = new Date().toISOString().split('T')[0].replace(/-/g, '');
  const random = Math.random().toString(36).substring(2, 8);
  return `refresh_${date}_${random}`;
}

async function main() {
  const batchId = generateBatchId();
  const startTime = new Date();

  log({
    timestamp: startTime.toISOString(),
    level: 'INFO',
    event: 'refresh_started',
    data: {
      batchId,
      targetBlogs: BLOGS_TO_REFRESH,
      minAgeDays: MIN_AGE_DAYS,
      timezone: 'America/Panama',
    },
  });

  let pool: Pool | null = null;

  try {
    const connectionString = process.env.DATABASE_URL;
    if (!connectionString) {
      throw new Error('DATABASE_URL no está configurado');
    }

    pool = new Pool({ connectionString });
    const db = drizzle(pool, { schema });

    log({
      timestamp: new Date().toISOString(),
      level: 'INFO',
      event: 'database_connected',
      data: { batchId },
    });

    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - MIN_AGE_DAYS);

    const oldBlogs = await db
      .select()
      .from(schema.blogs)
      .where(
        and(
          eq(schema.blogs.autoGenerated, 'true'),
          lt(schema.blogs.updatedAt, thirtyDaysAgo)
        )
      )
      .orderBy(asc(schema.blogs.updatedAt))
      .limit(BLOGS_TO_REFRESH);

    if (oldBlogs.length === 0) {
      log({
        timestamp: new Date().toISOString(),
        level: 'INFO',
        event: 'no_blogs_to_refresh',
        data: { batchId, message: 'All blogs are fresh enough' },
      });
      await pool.end();
      process.exit(0);
    }

    log({
      timestamp: new Date().toISOString(),
      level: 'INFO',
      event: 'blogs_found_for_refresh',
      data: { 
        batchId, 
        count: oldBlogs.length,
        blogs: oldBlogs.map(b => ({ id: b.id, title: b.title, lastUpdated: b.updatedAt })),
      },
    });

    const refreshedBlogs: string[] = [];
    const errors: string[] = [];

    for (const blog of oldBlogs) {
      try {
        const now = new Date();
        const currentYear = now.getFullYear();
        
        let updatedContent = blog.content;
        updatedContent = updatedContent.replace(/\b202[0-4]\b/g, String(currentYear));
        
        if (!updatedContent.includes('Actualizado')) {
          const updateNote = `<p><em>Artículo actualizado el ${now.toLocaleDateString('es-VE', { 
            day: 'numeric', 
            month: 'long', 
            year: 'numeric' 
          })}.</em></p>`;
          updatedContent = updatedContent + updateNote;
        } else {
          updatedContent = updatedContent.replace(
            /<p><em>Artículo actualizado el [^<]+<\/em><\/p>/,
            `<p><em>Artículo actualizado el ${now.toLocaleDateString('es-VE', { 
              day: 'numeric', 
              month: 'long', 
              year: 'numeric' 
            })}.</em></p>`
          );
        }

        await db
          .update(schema.blogs)
          .set({
            content: updatedContent,
            updatedAt: now,
            lastRefreshedAt: now,
          })
          .where(eq(schema.blogs.id, blog.id));

        refreshedBlogs.push(blog.title);

        log({
          timestamp: new Date().toISOString(),
          level: 'INFO',
          event: 'blog_refreshed',
          data: {
            id: blog.id,
            title: blog.title,
            slug: blog.slug,
            batchId,
          },
        });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        errors.push(`${blog.title}: ${errorMessage}`);
        log({
          timestamp: new Date().toISOString(),
          level: 'ERROR',
          event: 'blog_refresh_failed',
          data: {
            id: blog.id,
            title: blog.title,
            error: errorMessage,
            batchId,
          },
        });
      }
    }

    await db.insert(schema.blogGenerationLogs).values({
      batchId,
      executionDate: startTime,
      blogsGenerated: refreshedBlogs.length,
      blogsSkipped: errors.length,
      executionTimeMs: new Date().getTime() - startTime.getTime(),
      aiCallsCount: 0,
      imageCallsCount: 0,
      errors: errors.length > 0 ? errors : null,
      citiesUsed: [],
      sectorsUsed: [],
      status: errors.length === 0 ? 'completed' : 'partial',
      source: 'weekly_refresh',
    });

    const executionTimeMs = new Date().getTime() - startTime.getTime();

    log({
      timestamp: new Date().toISOString(),
      level: 'INFO',
      event: 'refresh_completed',
      data: {
        batchId,
        blogsRefreshed: refreshedBlogs.length,
        errors: errors.length,
        executionTimeMs,
        executionTimeSeconds: Math.round(executionTimeMs / 1000),
        refreshedTitles: refreshedBlogs,
      },
    });

    console.log('\n========== RESUMEN DE REFRESH SEMANAL ==========');
    console.log(`Batch ID: ${batchId}`);
    console.log(`Blogs refrescados: ${refreshedBlogs.length}/${BLOGS_TO_REFRESH}`);
    console.log(`Tiempo de ejecución: ${Math.round(executionTimeMs / 1000)}s`);
    if (refreshedBlogs.length > 0) {
      console.log('Blogs actualizados:');
      refreshedBlogs.forEach((t, i) => console.log(`  ${i + 1}. ${t}`));
    }
    if (errors.length > 0) {
      console.log(`Errores: ${errors.length}`);
      errors.forEach((e, i) => console.log(`  ${i + 1}. ${e}`));
    }
    console.log('=================================================\n');

    await pool.end();
    process.exit(0);

  } catch (error) {
    log({
      timestamp: new Date().toISOString(),
      level: 'ERROR',
      event: 'refresh_failed',
      data: {
        batchId,
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : 'N/A',
      },
    });

    if (pool) {
      await pool.end();
    }

    process.exit(1);
  }
}

main();
