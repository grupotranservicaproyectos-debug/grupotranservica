import { type User, type InsertUser, type ContactRequest, type InsertContactRequest, type ContactoRecibido, type InsertContactoRecibido, type Blog, type InsertBlog } from "@shared/schema";
import { randomUUID } from "crypto";

export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  createContactRequest(request: InsertContactRequest): Promise<ContactRequest>;
  getContactRequests(): Promise<ContactRequest[]>;
  createContactoRecibido(contacto: InsertContactoRecibido): Promise<ContactoRecibido>;
  getContactosRecibidos(): Promise<ContactoRecibido[]>;
  updateContactoEstado(id: string, estado: string): Promise<ContactoRecibido | undefined>;
  createBlog(blog: InsertBlog): Promise<Blog>;
  getBlogs(filters?: { city?: string; sector?: string; published?: string }): Promise<Blog[]>;
  getBlogBySlug(slug: string): Promise<Blog | undefined>;
  updateBlogViews(id: string): Promise<Blog | undefined>;
  getBlogStats(): Promise<{ totalBlogs: number; blogsThisMonth: number }>;
}

export class MemStorage implements IStorage {
  private users: Map<string, User>;
  private contactRequests: Map<string, ContactRequest>;
  private contactosRecibidos: Map<string, ContactoRecibido>;
  private blogs: Map<string, Blog>;

  constructor() {
    this.users = new Map();
    this.contactRequests = new Map();
    this.contactosRecibidos = new Map();
    this.blogs = new Map();
  }

  async getUser(id: string): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = randomUUID();
    const user: User = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }

  async createContactRequest(insertRequest: InsertContactRequest): Promise<ContactRequest> {
    const id = randomUUID();
    const contactRequest: ContactRequest = { 
      ...insertRequest,
      company: insertRequest.company ?? null,
      cargoType: insertRequest.cargoType ?? null,
      estimatedWeight: insertRequest.estimatedWeight ?? null,
      origin: insertRequest.origin ?? null,
      destination: insertRequest.destination ?? null,
      id,
      createdAt: new Date()
    };
    this.contactRequests.set(id, contactRequest);
    return contactRequest;
  }

  async getContactRequests(): Promise<ContactRequest[]> {
    return Array.from(this.contactRequests.values()).sort(
      (a, b) => (b.createdAt?.getTime() || 0) - (a.createdAt?.getTime() || 0)
    );
  }

  async createContactoRecibido(insertContacto: InsertContactoRecibido): Promise<ContactoRecibido> {
    const id = randomUUID();
    const contacto: ContactoRecibido = {
      ...insertContacto,
      canal: insertContacto.canal ?? "web",
      estado: insertContacto.estado ?? "pendiente",
      correosNotificados: insertContacto.correosNotificados ?? [],
      id,
      fechaRecibido: new Date()
    };
    this.contactosRecibidos.set(id, contacto);
    return contacto;
  }

  async getContactosRecibidos(): Promise<ContactoRecibido[]> {
    return Array.from(this.contactosRecibidos.values()).sort(
      (a, b) => (b.fechaRecibido?.getTime() || 0) - (a.fechaRecibido?.getTime() || 0)
    );
  }

  async updateContactoEstado(id: string, estado: string): Promise<ContactoRecibido | undefined> {
    const contacto = this.contactosRecibidos.get(id);
    if (!contacto) return undefined;
    const updated = { ...contacto, estado };
    this.contactosRecibidos.set(id, updated);
    return updated;
  }

  async createBlog(insertBlog: InsertBlog): Promise<Blog> {
    const id = randomUUID();
    const blog: Blog = {
      ...insertBlog,
      id,
      excerpt: insertBlog.excerpt ?? null,
      metaTitle: insertBlog.metaTitle ?? null,
      metaDescription: insertBlog.metaDescription ?? null,
      keywords: insertBlog.keywords ?? null,
      city: insertBlog.city ?? null,
      sector: insertBlog.sector ?? null,
      template: insertBlog.template ?? null,
      coverImage: insertBlog.coverImage ?? null,
      ogImage: insertBlog.ogImage ?? null,
      published: insertBlog.published ?? "true",
      autoGenerated: insertBlog.autoGenerated ?? "false",
      views: 0,
      createdAt: new Date(),
      updatedAt: new Date(),
      publishedAt: new Date(),
    };
    this.blogs.set(id, blog);
    return blog;
  }

  async getBlogs(filters?: { city?: string; sector?: string; published?: string }): Promise<Blog[]> {
    let blogs = Array.from(this.blogs.values());
    if (filters?.city) {
      blogs = blogs.filter(b => b.city === filters.city);
    }
    if (filters?.sector) {
      blogs = blogs.filter(b => b.sector === filters.sector);
    }
    if (filters?.published !== undefined) {
      blogs = blogs.filter(b => b.published === filters.published);
    }
    return blogs.sort((a, b) => (b.publishedAt?.getTime() || 0) - (a.publishedAt?.getTime() || 0));
  }

  async getBlogBySlug(slug: string): Promise<Blog | undefined> {
    return Array.from(this.blogs.values()).find(b => b.slug === slug);
  }

  async updateBlogViews(id: string): Promise<Blog | undefined> {
    const blog = this.blogs.get(id);
    if (!blog) return undefined;
    const updated = { ...blog, views: blog.views + 1 };
    this.blogs.set(id, updated);
    return updated;
  }

  async getBlogStats(): Promise<{ totalBlogs: number; blogsThisMonth: number }> {
    const now = new Date();
    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    const blogs = Array.from(this.blogs.values());
    const blogsThisMonth = blogs.filter(b => 
      b.createdAt && b.createdAt >= firstDayOfMonth
    ).length;
    return {
      totalBlogs: blogs.length,
      blogsThisMonth
    };
  }
}

import { db } from './lib/db';
import { users, contactRequests, contactosRecibidos, blogs } from '@shared/schema';
import { eq, desc, and, gte } from 'drizzle-orm';

export class DBStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.id, id));
    return result[0];
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.username, username));
    return result[0];
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const result = await db.insert(users).values(insertUser).returning();
    return result[0];
  }

  async createContactRequest(insertRequest: InsertContactRequest): Promise<ContactRequest> {
    const result = await db.insert(contactRequests).values(insertRequest).returning();
    return result[0];
  }

  async getContactRequests(): Promise<ContactRequest[]> {
    return await db.select().from(contactRequests).orderBy(desc(contactRequests.createdAt));
  }

  async createContactoRecibido(insertContacto: InsertContactoRecibido): Promise<ContactoRecibido> {
    const contactoData = {
      ...insertContacto,
      correosNotificados: insertContacto.correosNotificados || [],
    };
    const result = await db.insert(contactosRecibidos).values(contactoData).returning();
    return result[0];
  }

  async getContactosRecibidos(): Promise<ContactoRecibido[]> {
    return await db.select().from(contactosRecibidos).orderBy(desc(contactosRecibidos.fechaRecibido));
  }

  async updateContactoEstado(id: string, estado: string): Promise<ContactoRecibido | undefined> {
    const result = await db.update(contactosRecibidos)
      .set({ estado })
      .where(eq(contactosRecibidos.id, id))
      .returning();
    return result[0];
  }

  async createBlog(insertBlog: InsertBlog): Promise<Blog> {
    const result = await db.insert(blogs).values(insertBlog).returning();
    return result[0];
  }

  async getBlogs(filters?: { city?: string; sector?: string; published?: string }): Promise<Blog[]> {
    const conditions = [];
    if (filters?.city) {
      conditions.push(eq(blogs.city, filters.city));
    }
    if (filters?.sector) {
      conditions.push(eq(blogs.sector, filters.sector));
    }
    if (filters?.published !== undefined) {
      conditions.push(eq(blogs.published, filters.published));
    }
    
    if (conditions.length > 0) {
      return await db.select().from(blogs).where(and(...conditions)).orderBy(desc(blogs.publishedAt));
    }
    return await db.select().from(blogs).orderBy(desc(blogs.publishedAt));
  }

  async getBlogBySlug(slug: string): Promise<Blog | undefined> {
    const result = await db.select().from(blogs).where(eq(blogs.slug, slug));
    return result[0];
  }

  async updateBlogViews(id: string): Promise<Blog | undefined> {
    const blog = await db.select().from(blogs).where(eq(blogs.id, id));
    if (!blog[0]) return undefined;
    
    const result = await db.update(blogs)
      .set({ views: blog[0].views + 1 })
      .where(eq(blogs.id, id))
      .returning();
    return result[0];
  }

  async getBlogStats(): Promise<{ totalBlogs: number; blogsThisMonth: number }> {
    const now = new Date();
    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    
    const totalResult = await db.select().from(blogs);
    const monthResult = await db.select().from(blogs).where(gte(blogs.createdAt, firstDayOfMonth));
    
    return {
      totalBlogs: totalResult.length,
      blogsThisMonth: monthResult.length,
    };
  }
}

export const storage = new DBStorage();
