import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import {
  insertContactRequestSchema,
  contactFormSchema,
  insertContactoRecibidoSchema,
  insertBlogSchema,
  blogs,
  blogGenerationLogs,
} from "@shared/schema";
import { z } from "zod";
import { sendNotificationEmails, sendConfirmationEmail } from "./email";
import { generateBlog, generate5Blogs } from "./lib/blogGenerator";
import { requireAdmin } from "./middleware/auth";
import { blogGenerationRateLimit } from "./middleware/rateLimit";
import { db } from "./lib/db";
import { desc, gte, eq, and, sql, lt, count } from "drizzle-orm";

export async function registerRoutes(app: Express): Promise<Server> {
  // Google Site Verification files - must be before Vite middleware
  app.get("/google8f9cfe36ab6897c8.html", (req, res) => {
    res.type("text/html").send("google-site-verification: google8f9cfe36ab6897c8.html");
  });

  // Sitemap redirect - 301 permanent redirect to XML sitemap
  app.get("/sitemap", (req, res) => {
    res.redirect(301, "/api/sitemap.xml");
  });

  app.get("/sitemap.xml", (req, res) => {
    res.redirect(301, "/api/sitemap.xml");
  });

  // Admin SEO Stats endpoint - protected by query param
  app.get("/api/admin/seo-stats", async (req, res) => {
    try {
      const { token } = req.query;
      const adminToken = process.env.ADMIN_TOKEN;

      if (!adminToken || token !== adminToken) {
        return res.status(401).json({
          success: false,
          message: "Acceso no autorizado",
        });
      }

      const now = new Date();
      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);

      // 1. Blogs generados por día (últimos 30 días)
      const blogsPerDay = await db
        .select({
          date: sql<string>`DATE(published_at)::text`,
          count: sql<number>`count(*)::int`,
          autoGenerated: sql<number>`sum(case when auto_generated = 'true' then 1 else 0 end)::int`,
        })
        .from(blogs)
        .where(gte(blogs.publishedAt, thirtyDaysAgo))
        .groupBy(sql`DATE(published_at)`)
        .orderBy(sql`DATE(published_at) DESC`);

      // 2. Top 10 URLs por views
      const topUrls = await db
        .select({
          id: blogs.id,
          title: blogs.title,
          slug: blogs.slug,
          city: blogs.city,
          sector: blogs.sector,
          template: blogs.template,
          views: blogs.views,
          publishedAt: blogs.publishedAt,
        })
        .from(blogs)
        .where(eq(blogs.published, "true"))
        .orderBy(desc(blogs.views))
        .limit(10);

      // 3. Distribución por ciudad
      const byCity = await db
        .select({
          city: blogs.city,
          count: sql<number>`count(*)::int`,
          totalViews: sql<number>`sum(views)::int`,
        })
        .from(blogs)
        .where(eq(blogs.autoGenerated, "true"))
        .groupBy(blogs.city)
        .orderBy(sql`count(*) DESC`)
        .limit(15);

      // 4. Distribución por sector
      const bySector = await db
        .select({
          sector: blogs.sector,
          count: sql<number>`count(*)::int`,
          totalViews: sql<number>`sum(views)::int`,
        })
        .from(blogs)
        .where(eq(blogs.autoGenerated, "true"))
        .groupBy(blogs.sector)
        .orderBy(sql`count(*) DESC`)
        .limit(10);

      // 5. Distribución por template
      const byTemplate = await db
        .select({
          template: blogs.template,
          count: sql<number>`count(*)::int`,
          totalViews: sql<number>`sum(views)::int`,
        })
        .from(blogs)
        .where(eq(blogs.autoGenerated, "true"))
        .groupBy(blogs.template)
        .orderBy(sql`count(*) DESC`);

      // 6. Errores recientes desde blog_generation_logs
      const recentLogs = await db
        .select()
        .from(blogGenerationLogs)
        .orderBy(desc(blogGenerationLogs.executionDate))
        .limit(10);

      // 7. Métricas para semáforo de estado
      const blogsYesterday = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(blogs)
        .where(
          and(
            eq(blogs.autoGenerated, "true"),
            gte(blogs.publishedAt, yesterday),
          ),
        );

      const expectedDailyBlogs = 4;
      const actualYesterday = blogsYesterday[0]?.count || 0;

      const failedLogs = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(blogGenerationLogs)
        .where(
          and(
            eq(blogGenerationLogs.status, "failed"),
            gte(blogGenerationLogs.executionDate, sevenDaysAgo),
          ),
        );

      // Calcular estado del sistema
      let systemStatus: "healthy" | "degraded" | "unhealthy" = "healthy";
      let statusReason = "Sistema operando normalmente";

      if (failedLogs[0]?.count > 0) {
        systemStatus = "unhealthy";
        statusReason = `${failedLogs[0].count} generaciones fallidas en los últimos 7 días`;
      } else if (actualYesterday < expectedDailyBlogs * 0.5) {
        systemStatus = "degraded";
        statusReason = `Solo ${actualYesterday}/${expectedDailyBlogs} blogs generados ayer`;
      } else if (actualYesterday < expectedDailyBlogs) {
        systemStatus = "degraded";
        statusReason = `${actualYesterday}/${expectedDailyBlogs} blogs generados ayer (por debajo del objetivo)`;
      }

      // 8. Totales generales
      const totalBlogs = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(blogs);

      const totalAutoGenerated = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(blogs)
        .where(eq(blogs.autoGenerated, "true"));

      const totalViews = await db
        .select({ sum: sql<number>`sum(views)::int` })
        .from(blogs);

      // 9. Combinaciones ciudad/sector con más de 3 posts (canibalización) - con posts detallados
      const overusedCombinationsRaw = await db
        .select({
          city: blogs.city,
          sector: blogs.sector,
          count: sql<number>`count(*)::int`,
        })
        .from(blogs)
        .where(eq(blogs.autoGenerated, "true"))
        .groupBy(blogs.city, blogs.sector)
        .having(sql`count(*) >= 3`)
        .orderBy(sql`count(*) DESC`)
        .limit(10);

      // Obtener posts detallados para cada combinación canibalizada
      const overusedCombinations = await Promise.all(
        overusedCombinationsRaw.map(async (combo) => {
          const posts = await db
            .select({
              id: blogs.id,
              title: blogs.title,
              slug: blogs.slug,
              views: blogs.views,
              publishedAt: blogs.publishedAt,
            })
            .from(blogs)
            .where(
              and(
                eq(blogs.autoGenerated, "true"),
                eq(blogs.city, combo.city || ""),
                eq(blogs.sector, combo.sector || ""),
              ),
            )
            .orderBy(desc(blogs.views))
            .limit(10);

          return {
            city: combo.city,
            sector: combo.sector,
            count: combo.count,
            posts,
          };
        }),
      );

      // 10. Calcular ciudades y sectores con menor cobertura (para sugerir priorización)
      const allCities = [
        "caracas",
        "maracaibo",
        "valencia",
        "barquisimeto",
        "maracay",
        "puerto-cabello",
        "punto-fijo",
        "ciudad-guayana",
        "maturin",
        "barcelona",
      ];
      const allSectors = [
        "petrolero",
        "petroquimico",
        "siderurgico",
        "minero",
        "construccion",
        "energia",
        "industrial",
      ];

      // Encontrar ciudades con poca cobertura
      const cityCoverage = allCities
        .map((city) => {
          const found = byCity.find((c) => c.city === city);
          return {
            city,
            count: found?.count || 0,
            totalViews: found?.totalViews || 0,
          };
        })
        .sort((a, b) => a.count - b.count);

      // Encontrar sectores con poca cobertura
      const sectorCoverage = allSectors
        .map((sector) => {
          const found = bySector.find((s) => s.sector === sector);
          return {
            sector,
            count: found?.count || 0,
            totalViews: found?.totalViews || 0,
          };
        })
        .sort((a, b) => a.count - b.count);

      // 11. Generar recomendaciones automáticas
      const recommendations: Array<{
        type: "priority" | "warning" | "action";
        title: string;
        description: string;
        details?: { city?: string; sector?: string; count?: number };
      }> = [];

      // Recomendar ciudades con poca cobertura
      const lowCoverageCities = cityCoverage.filter((c) => c.count < 3);
      if (lowCoverageCities.length > 0) {
        const topCities = lowCoverageCities.slice(0, 3);
        recommendations.push({
          type: "priority",
          title: "Priorizar ciudades con baja cobertura",
          description: `Las ciudades ${topCities.map((c) => c.city).join(", ")} tienen menos de 3 posts cada una. Considera priorizar contenido para estas ubicaciones.`,
          details: { city: topCities[0]?.city, count: topCities[0]?.count },
        });
      }

      // Recomendar sectores con poca cobertura
      const lowCoverageSectors = sectorCoverage.filter((s) => s.count < 3);
      if (lowCoverageSectors.length > 0) {
        const topSectors = lowCoverageSectors.slice(0, 2);
        recommendations.push({
          type: "priority",
          title: "Expandir cobertura de sectores",
          description: `Los sectores ${topSectors.map((s) => s.sector).join(", ")} tienen poca cobertura. Genera contenido para diversificar.`,
          details: {
            sector: topSectors[0]?.sector,
            count: topSectors[0]?.count,
          },
        });
      }

      // Advertir sobre canibalización
      if (overusedCombinations.length > 0) {
        const worstCombo = overusedCombinations[0];
        recommendations.push({
          type: "warning",
          title: "Reducir generación en áreas saturadas",
          description: `La combinación ${worstCombo.city}/${worstCombo.sector} tiene ${worstCombo.count} posts. Considera pausar generación aquí o combinar contenido duplicado.`,
          details: {
            city: worstCombo.city || "",
            sector: worstCombo.sector || "",
            count: worstCombo.count,
          },
        });
      }

      // Sugerir acción si no hubo generación ayer
      if (actualYesterday === 0) {
        recommendations.push({
          type: "action",
          title: "Verificar sistema de generación",
          description:
            "No se generaron blogs ayer. Revisa los logs del Scheduled Deployment y verifica que el cron esté configurado correctamente.",
        });
      }

      // Sugerir diversificar templates si hay desbalance
      const templateCounts = byTemplate.map((t) => t.count);
      const maxTemplate = Math.max(...templateCounts);
      const minTemplate = Math.min(...templateCounts);
      if (maxTemplate > minTemplate * 3 && byTemplate.length > 1) {
        const dominantTemplate = byTemplate.find(
          (t) => t.count === maxTemplate,
        );
        const rareTemplate = byTemplate.find((t) => t.count === minTemplate);
        recommendations.push({
          type: "priority",
          title: "Balancear tipos de contenido",
          description: `El template "${dominantTemplate?.template}" domina con ${maxTemplate} posts, mientras "${rareTemplate?.template}" solo tiene ${minTemplate}. Considera equilibrar la mezcla de templates.`,
        });
      }

      // Si todo está bien, agregar recomendación positiva
      if (recommendations.length === 0 && systemStatus === "healthy") {
        recommendations.push({
          type: "priority",
          title: "Sistema funcionando correctamente",
          description:
            "No hay acciones urgentes. Continúa monitoreando el rendimiento de las URLs y ajusta la estrategia según las vistas.",
        });
      }

      res.json({
        success: true,
        timestamp: now.toISOString(),
        systemStatus: {
          status: systemStatus,
          reason: statusReason,
          expectedDaily: expectedDailyBlogs,
          actualYesterday: actualYesterday,
          failedGenerations7Days: failedLogs[0]?.count || 0,
        },
        totals: {
          totalBlogs: totalBlogs[0]?.count || 0,
          totalAutoGenerated: totalAutoGenerated[0]?.count || 0,
          totalViews: totalViews[0]?.sum || 0,
        },
        blogsPerDay,
        topUrls,
        distribution: {
          byCity,
          bySector,
          byTemplate,
        },
        overusedCombinations,
        recommendations,
        coverage: {
          cities: cityCoverage,
          sectors: sectorCoverage,
        },
        recentLogs: recentLogs.map((log) => ({
          batchId: log.batchId,
          executionDate: log.executionDate,
          status: log.status,
          blogsGenerated: log.blogsGenerated,
          blogsSkipped: log.blogsSkipped,
          executionTimeMs: log.executionTimeMs,
          aiCallsCount: log.aiCallsCount,
          imageCallsCount: log.imageCallsCount,
          errors: log.errors || [],
          citiesUsed: log.citiesUsed || [],
          sectorsUsed: log.sectorsUsed || [],
          source: log.source,
        })),
      });
    } catch (error) {
      console.error("Error in /api/admin/seo-stats:", error);
      res.status(500).json({
        success: false,
        message: "Error al obtener estadísticas",
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  });

  // Contact form submission
  app.post("/api/contact", async (req, res) => {
    try {
      const validatedData = insertContactRequestSchema.parse(req.body);
      const contactRequest = await storage.createContactRequest(validatedData);

      // In a real application, you would send an email notification here
      console.log("New contact request:", contactRequest);

      res.json({
        success: true,
        message:
          "Solicitud de cotización enviada exitosamente. Nos pondremos en contacto contigo pronto.",
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          success: false,
          message: "Datos inválidos",
          errors: error.errors,
        });
      } else {
        res.status(500).json({
          success: false,
          message: "Error interno del servidor",
        });
      }
    }
  });

  // Get all contact requests (for admin purposes)
  app.get("/api/contact-requests", async (req, res) => {
    try {
      const requests = await storage.getContactRequests();
      res.json(requests);
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Error al obtener solicitudes",
      });
    }
  });

  // New contact endpoint with email notifications
  app.post("/api/contacto", async (req, res) => {
    try {
      // Validate input data from frontend (without correosNotificados)
      const validatedData = contactFormSchema.parse(req.body);

      // Try to send notification emails but don't fail if email service is down
      let emailResults: string[] = [];
      try {
        emailResults = await sendNotificationEmails({
          nombre: validatedData.nombre,
          correo: validatedData.correoContacto,
          telefono: validatedData.telefono,
          asunto: validatedData.asunto,
          mensaje: validatedData.mensaje,
        });

        // Send confirmation email to user (don't wait for it)
        sendConfirmationEmail(
          validatedData.correoContacto,
          validatedData.nombre,
        ).catch((error) => {
          console.error("Error sending confirmation email:", error);
        });
      } catch (emailError) {
        console.error(
          "Email service unavailable, but contact will be saved:",
          emailError,
        );
        emailResults = [];
      }

      // Always store in database even if email fails
      const contacto = await storage.createContactoRecibido({
        ...validatedData,
        correosNotificados: emailResults,
      });

      res.json({
        success: true,
        message:
          "Tu mensaje ha sido recibido exitosamente. Te contactaremos pronto.",
        data: {
          id: contacto.id,
          notificacionesEnviadas: emailResults.length,
        },
      });
    } catch (error) {
      console.error("Error in /api/contacto:", error);

      if (error instanceof z.ZodError) {
        res.status(400).json({
          success: false,
          message: "Datos inválidos en el formulario",
          errors: error.errors,
        });
      } else {
        res.status(500).json({
          success: false,
          message:
            "Error al procesar tu solicitud. Por favor intenta nuevamente.",
        });
      }
    }
  });

  // Get all contactos (for admin purposes)
  app.get("/api/contactos", async (req, res) => {
    try {
      const contactos = await storage.getContactosRecibidos();
      res.json(contactos);
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Error al obtener contactos",
      });
    }
  });

  // Blog routes
  app.get("/api/blogs", async (req, res) => {
    try {
      const { city, sector, published } = req.query;
      const filters: any = {};
      if (city) filters.city = city as string;
      if (sector) filters.sector = sector as string;
      if (published !== undefined) filters.published = published as string;

      const blogs = await storage.getBlogs(filters);
      res.json({ data: blogs });
    } catch (error) {
      console.error("Error fetching blogs:", error);
      res.status(500).json({
        success: false,
        message: "Error al obtener blogs",
      });
    }
  });

  app.get("/api/blogs/stats", async (req, res) => {
    try {
      const stats = await storage.getBlogStats();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching blog stats:", error);
      res.status(500).json({
        success: false,
        message: "Error al obtener estadísticas",
      });
    }
  });

  app.get("/api/blogs/health", async (req, res) => {
    try {
      const now = new Date();
      const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

      const latestAutoGeneratedBlog = await db
        .select({
          id: blogs.id,
          title: blogs.title,
          publishedAt: blogs.publishedAt,
          city: blogs.city,
          sector: blogs.sector,
          generationBatchId: blogs.generationBatchId,
        })
        .from(blogs)
        .where(eq(blogs.autoGenerated, "true"))
        .orderBy(desc(blogs.publishedAt))
        .limit(1);

      const blogsLast7Days = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(blogs)
        .where(
          and(
            eq(blogs.autoGenerated, "true"),
            gte(blogs.publishedAt, sevenDaysAgo),
          ),
        );

      const blogsLast30Days = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(blogs)
        .where(
          and(
            eq(blogs.autoGenerated, "true"),
            gte(blogs.publishedAt, thirtyDaysAgo),
          ),
        );

      const totalAutoBlogs = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(blogs)
        .where(eq(blogs.autoGenerated, "true"));

      const recentLogs = await db
        .select()
        .from(blogGenerationLogs)
        .orderBy(desc(blogGenerationLogs.executionDate))
        .limit(5);

      const failedLogsLast7Days = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(blogGenerationLogs)
        .where(
          and(
            eq(blogGenerationLogs.status, "failed"),
            gte(blogGenerationLogs.executionDate, sevenDaysAgo),
          ),
        );

      const latestLog = recentLogs[0];
      const lastBlog = latestAutoGeneratedBlog[0];

      const timeSinceLastGeneration = lastBlog?.publishedAt
        ? Math.floor(
            (now.getTime() - new Date(lastBlog.publishedAt).getTime()) /
              (1000 * 60 * 60),
          )
        : null;

      const status = {
        healthy:
          blogsLast7Days[0]?.count > 0 && failedLogsLast7Days[0]?.count === 0,
        lastGenerationHoursAgo: timeSinceLastGeneration,
      };

      res.json({
        status: status.healthy ? "healthy" : "warning",
        timestamp: now.toISOString(),
        metrics: {
          lastAutoGeneratedBlog: lastBlog
            ? {
                id: lastBlog.id,
                title: lastBlog.title,
                publishedAt: lastBlog.publishedAt,
                city: lastBlog.city,
                sector: lastBlog.sector,
                batchId: lastBlog.generationBatchId,
              }
            : null,
          blogsLast7Days: blogsLast7Days[0]?.count || 0,
          blogsLast30Days: blogsLast30Days[0]?.count || 0,
          totalAutoGeneratedBlogs: totalAutoBlogs[0]?.count || 0,
          hoursSinceLastGeneration: timeSinceLastGeneration,
        },
        recentGenerationLogs: recentLogs.map((log) => ({
          batchId: log.batchId,
          executionDate: log.executionDate,
          status: log.status,
          blogsGenerated: log.blogsGenerated,
          blogsSkipped: log.blogsSkipped,
          executionTimeMs: log.executionTimeMs,
          errorsCount: log.errors?.length || 0,
          source: log.source,
        })),
        errors: {
          failedGenerationsLast7Days: failedLogsLast7Days[0]?.count || 0,
          latestErrors: latestLog?.errors || [],
        },
        schedule: {
          cron: "30 6 * * *",
          timezone: "America/Panama",
          nextScheduledTime: "6:30 AM tomorrow",
        },
      });
    } catch (error) {
      console.error("Error in /api/blogs/health:", error);
      res.status(500).json({
        status: "error",
        timestamp: new Date().toISOString(),
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  });

  app.get("/api/blogs/:slug/related", async (req, res) => {
    try {
      const blog = await storage.getBlogBySlug(req.params.slug);
      if (!blog) {
        return res.status(404).json({
          success: false,
          message: "Blog no encontrado",
        });
      }

      const relatedBlogs: any[] = [];
      const addedIds = new Set<string>();

      // Priority 1: Same city AND sector
      if (blog.city && blog.sector && relatedBlogs.length < 4) {
        const cityAndSectorBlogs = await storage.getBlogs({
          city: blog.city,
          sector: blog.sector,
          published: "true",
        });
        for (const b of cityAndSectorBlogs) {
          if (
            b.slug !== blog.slug &&
            !addedIds.has(b.id) &&
            relatedBlogs.length < 4
          ) {
            relatedBlogs.push(b);
            addedIds.add(b.id);
          }
        }
      }

      // Priority 2: Same city
      if (blog.city && relatedBlogs.length < 4) {
        const cityBlogs = await storage.getBlogs({
          city: blog.city,
          published: "true",
        });
        for (const b of cityBlogs) {
          if (
            b.slug !== blog.slug &&
            !addedIds.has(b.id) &&
            relatedBlogs.length < 4
          ) {
            relatedBlogs.push(b);
            addedIds.add(b.id);
          }
        }
      }

      // Priority 3: Same sector
      if (blog.sector && relatedBlogs.length < 4) {
        const sectorBlogs = await storage.getBlogs({
          sector: blog.sector,
          published: "true",
        });
        for (const b of sectorBlogs) {
          if (
            b.slug !== blog.slug &&
            !addedIds.has(b.id) &&
            relatedBlogs.length < 4
          ) {
            relatedBlogs.push(b);
            addedIds.add(b.id);
          }
        }
      }

      // Priority 4: Any other published blog (fallback to guarantee at least 1 result)
      if (relatedBlogs.length < 4) {
        const allBlogs = await storage.getBlogs({ published: "true" });
        for (const b of allBlogs) {
          if (
            b.slug !== blog.slug &&
            !addedIds.has(b.id) &&
            relatedBlogs.length < 4
          ) {
            relatedBlogs.push(b);
            addedIds.add(b.id);
          }
        }
      }

      res.json({ data: relatedBlogs });
    } catch (error) {
      console.error("Error fetching related blogs:", error);
      res.status(500).json({
        success: false,
        message: "Error al obtener blogs relacionados",
      });
    }
  });

  app.get("/api/blogs/:slug", async (req, res) => {
    try {
      const blog = await storage.getBlogBySlug(req.params.slug);
      if (!blog) {
        return res.status(404).json({
          success: false,
          message: "Blog no encontrado",
        });
      }

      await storage.updateBlogViews(blog.id);
      res.json(blog);
    } catch (error) {
      console.error("Error fetching blog:", error);
      res.status(500).json({
        success: false,
        message: "Error al obtener blog",
      });
    }
  });

  app.post(
    "/api/blogs/generate",
    requireAdmin,
    blogGenerationRateLimit,
    async (req, res) => {
      try {
        const blog = await generateBlog();
        const createdBlog = await storage.createBlog(blog);
        res.json({
          success: true,
          message: "Blog generado exitosamente",
          data: createdBlog,
        });
      } catch (error) {
        console.error("Error generating blog:", error);
        res.status(500).json({
          success: false,
          message: "Error al generar blog",
        });
      }
    },
  );

  app.post(
    "/api/blogs/generate-batch",
    requireAdmin,
    blogGenerationRateLimit,
    async (req, res) => {
      try {
        const blogs = await generate5Blogs();
        const createdBlogs = [];

        for (const blog of blogs) {
          const created = await storage.createBlog(blog);
          createdBlogs.push(created);
        }

        res.json({
          success: true,
          message: `${createdBlogs.length} blogs generados exitosamente`,
          data: createdBlogs,
        });
      } catch (error) {
        console.error("Error generating blogs:", error);
        res.status(500).json({
          success: false,
          message: "Error al generar blogs",
        });
      }
    },
  );

  app.post(
    "/api/blogs/:id/regenerate-images",
    requireAdmin,
    async (req, res) => {
      try {
        const { id } = req.params;
        const blog = await storage.getBlogById(id);

        if (!blog) {
          return res.status(404).json({
            success: false,
            message: "Blog no encontrado",
          });
        }

        const { getBlogImages } = await import("./lib/imageService");
        const images = await getBlogImages(
          blog.city || "caracas",
          blog.sector || "industrial",
        );

        const updated = await storage.updateBlogImages(
          id,
          images.coverImage,
          images.secondaryImages,
        );

        res.json({
          success: true,
          message: "Imágenes actualizadas exitosamente",
          data: updated,
        });
      } catch (error) {
        console.error("Error regenerating images:", error);
        res.status(500).json({
          success: false,
          message: "Error al regenerar imágenes",
        });
      }
    },
  );

  app.get("/api/sitemap.xml", async (req, res) => {
    try {
      const blogs = await storage.getBlogs({ published: "true" });
      
      // Detectar dominio dinámicamente desde el request
      const protocol = req.get("x-forwarded-proto") || req.protocol || "https";
      const host = req.get("host") || "grupotranservica.com";
      const baseUrl = `${protocol}://${host}`;

      let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
      xml += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n';

      const today = new Date().toISOString().split('T')[0];
      const mainPages = [
        { loc: "/", changefreq: "weekly", priority: 1.0, lastmod: today },
        { loc: "/blog", changefreq: "daily", priority: 0.9, lastmod: today },
        { loc: "/seo-blog", changefreq: "daily", priority: 0.9, lastmod: today },
        { loc: "/terms", changefreq: "monthly", priority: 0.5, lastmod: "2025-11-01" },
        { loc: "/privacy", changefreq: "monthly", priority: 0.5, lastmod: "2025-11-01" },
        { loc: "/cookies", changefreq: "monthly", priority: 0.5, lastmod: "2025-11-01" },
        { loc: "/security", changefreq: "monthly", priority: 0.5, lastmod: "2025-11-01" },
      ];

      mainPages.forEach((page) => {
        xml += "  <url>\n";
        xml += `    <loc>${baseUrl}${page.loc}</loc>\n`;
        xml += `    <lastmod>${page.lastmod}</lastmod>\n`;
        xml += `    <changefreq>${page.changefreq}</changefreq>\n`;
        xml += `    <priority>${page.priority}</priority>\n`;
        xml += "  </url>\n";
      });

      blogs.forEach((blog) => {
        xml += "  <url>\n";
        xml += `    <loc>${baseUrl}/seo-blog/${blog.slug}</loc>\n`;
        const lastmod =
          blog.publishedAt instanceof Date
            ? blog.publishedAt.toISOString()
            : blog.publishedAt || new Date().toISOString();
        xml += `    <lastmod>${lastmod}</lastmod>\n`;
        xml += "    <changefreq>monthly</changefreq>\n";
        xml += "    <priority>0.8</priority>\n";
        xml += "  </url>\n";
      });

      xml += "</urlset>";

      res.header("Content-Type", "application/xml");
      res.send(xml);
    } catch (error) {
      console.error("Error generating sitemap:", error);
      res.status(500).send("Error generating sitemap");
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
