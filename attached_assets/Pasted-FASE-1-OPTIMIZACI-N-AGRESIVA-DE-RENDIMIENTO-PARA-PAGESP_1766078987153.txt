FASE 1: OPTIMIZACIÓN AGRESIVA DE RENDIMIENTO PARA PAGESPEED 90+ EN MOBILE Y DESKTOP

CONTEXTO ACTUAL:
- Mobile Performance: 57/100 → META: 90+
- Desktop Performance: 86/100 → META: 95+
- FCP Mobile: 2.6s → META: <1.8s
- LCP Mobile: 9.8s → META: <2.5s
- TBT Mobile: 470ms → META: <200ms
- Speed Index Mobile: 4.5s → META: <3.4s
- Total Blocking Time Desktop: 200ms (ya cerca, mantener <200ms)

PROBLEMAS CRÍTICOS IDENTIFICADOS EN PAGESPEED INSIGHTS:

1. **IMÁGENES (PRIORIDAD MÁXIMA)**
   - Ahorro estimado: 419 KiB (mobile) / 414 KiB (desktop)
   - Acción requerida: Implementar optimización agresiva de imágenes

2. **JAVASCRIPT NO UTILIZADO**
   - Ahorro estimado: 1074 KiB (mobile) / 1078 KiB (desktop)
   - Tiempo de ejecución JS: 1.6s
   - Trabajo del hilo principal: 2.8s
   - 8 tareas largas encontradas (mobile) / 4 tareas largas (desktop)

3. **CSS NO UTILIZADO**
   - Ahorro estimado: 14 KiB (mobile) / 13 KiB (desktop)

4. **CACHE**
   - Ahorro estimado: 100 KiB (mobile) / 621 KiB (desktop)

5. **PAYLOAD DE RED**
   - Tamaño total: 3781 KiB (mobile) / 4048 KiB (desktop)

6. **RECURSOS QUE BLOQUEAN EL RENDERIZADO**
   - Visualización de fuentes: ahorro 10ms
   - Solicitudes que bloquean renderizado detectadas

7. **DESCUBRIMIENTO LCP Y ÁRBOL DE DEPENDENCIAS**
   - Optimizar ruta crítica para LCP

INSTRUCCIONES DETALLADAS PARA REPLIT AI:

**A. OPTIMIZACIÓN DE IMÁGENES (CRÍTICO - 419 KiB)**

1. **Conversión y Formato:**
Implementar conversión automática de todas las imágenes a formato WebP con fallback JPEG

Para imágenes >100KB: calidad WebP 80%, para <100KB: calidad 85%

Implementar compresión con sharp o imagemin en el backend

Generar versiones responsive: 320w, 640w, 1024w, 1920w para cada imagen

text

2. **Lazy Loading Agresivo:**
Aplicar loading="lazy" a TODAS las imágenes excepto:

Hero image (primera imagen above-the-fold)

Logo en header

Implementar intersection observer para imágenes críticas

Añadir fetchpriority="high" solo a la imagen hero del LCP

text

3. **Dimensiones Explícitas:**
Añadir width y height explícitos a TODAS las etiquetas <img>

Implementar aspect-ratio CSS para prevenir layout shifts

Ejemplo: <img src="..." width="800" height="600" loading="lazy" />

text

4. **Srcset y Sizes:**
Implementar srcset para todas las imágenes:
<img src="imagen-800w.webp" srcset="imagen-320w.webp 320w, imagen-640w.webp 640w, imagen-1024w.webp 1024w" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 800px" loading="lazy" width="800" height="600" alt="descripción" />

text

**B. REDUCCIÓN DE JAVASCRIPT (CRÍTICO - 1074 KiB)**

1. **Code Splitting Agresivo:**
// vite.config.ts
export default defineConfig({
build: {
rollupOptions: {
output: {
manualChunks: {
'react-vendor': ['react', 'react-dom', 'react-router-dom'],
'ui-vendor': ['framer-motion', 'lucide-react'],
'form-vendor': ['react-hook-form', 'zod'],
}
}
},
chunkSizeWarningLimit: 500,
minify: 'terser',
terserOptions: {
compress: {
drop_console: true,
drop_debugger: true,
pure_funcs: ['console.log', 'console.info'],
}
}
}
})

text

2. **Lazy Loading de Rutas:**
// client/src/App.tsx
import { lazy, Suspense } from 'react';

const HomePage = lazy(() => import('./pages/Home'));
const ServiciosPage = lazy(() => import('./pages/Servicios'));
const ProyectosPage = lazy(() => import('./pages/Proyectos'));
const BlogPage = lazy(() => import('./pages/Blog'));
const ContactoPage = lazy(() => import('./pages/Contacto'));

// Envolver en Suspense con loading skeleton
<Suspense fallback={<PageLoader />}>
<Routes>
<Route path="/" element={<HomePage />} />
<Route path="/servicios" element={<ServiciosPage />} />
...
</Routes>
</Suspense>

text

3. **Reducir Dependencias:**
Auditar package.json y eliminar librerías no usadas

Reemplazar librerías pesadas por alternativas ligeras

Considerar tree-shaking efectivo verificando imports

text

4. **Defer y Async Scripts:**
<!-- client/index.html --> <script type="module" src="/src/main.tsx" defer></script>
Asegurar que todos los scripts externos usen defer o async

text

**C. CSS OPTIMIZATION (14 KiB)**

1. **Critical CSS Inline:**
Extraer CSS crítico above-the-fold e incluirlo inline en <head>

Mover CSS no crítico para carga diferida

Usar herramienta critical o critters en Vite

text

2. **PurgeCSS:**
// vite.config.ts
import { purgeCss } from 'vite-plugin-tailwind-purgecss';

plugins: [
purgeCss({
content: ['./client/index.html', './client/src/**/*.{js,ts,jsx,tsx}']
})
]

text

3. **Minificación CSS:**
build: {
cssMinify: 'lightningcss',
cssCodeSplit: true,
}

text

**D. CACHE HEADERS (100-621 KiB)**

// server/index.ts o middleware
app.use((req, res, next) => {
// Imágenes: 1 año
if (req.url.match(/.(jpg|jpeg|png|gif|webp|svg|ico)$/)) {
res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
}
// JS/CSS: 1 año (versionado con hash)
else if (req.url.match(/.(js|css)$/)) {
res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
}
// Fuentes: 1 año
else if (req.url.match(/.(woff|woff2|ttf|eot)$/)) {
res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
}
// HTML: sin cache o cache corto
else if (req.url.match(/.html$/) || req.url === '/') {
res.setHeader('Cache-Control', 'public, max-age=0, must-revalidate');
}
next();
});

text

**E. COMPRESIÓN (Brotli + Gzip)**

import compression from 'compression';

// Habilitar compresión Brotli si está disponible, si no Gzip
app.use(compression({
filter: (req, res) => {
if (req.headers['x-no-compression']) return false;
return compression.filter(req, res);
},
level: 9, // Nivel máximo de compresión
}));

// O mejor aún, usar express-static-gzip si sirves archivos estáticos
import expressStaticGzip from 'express-static-gzip';

app.use('/', expressStaticGzip('dist/public', {
enableBrotli: true,
orderPreference: ['br', 'gz'],
}));

text

**F. FONT OPTIMIZATION**

/* Preload critical fonts */

<link rel="preload" href="/fonts/primary-font.woff2" as="font" type="font/woff2" crossorigin />
/* Font display swap */
@font-face {
font-family: 'Primary Font';
src: url('/fonts/primary-font.woff2') format('woff2');
font-display: swap;
font-weight: 400;
font-style: normal;
}

text
undefined
<!-- Preconnect a Google Fonts si se usa --> <link rel="preconnect" href="https://fonts.googleapis.com" /> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /> ```
G. PRELOAD/PREFETCH CRÍTICO

text
<!-- client/index.html - En <head> -->
<!-- Preload imagen hero (LCP) -->
<link rel="preload" as="image" href="/hero-image.webp" type="image/webp" />

<!-- Preload fuentes críticas -->
<link rel="preload" href="/fonts/font.woff2" as="font" type="font/woff2" crossorigin />

<!-- Preconnect a dominios externos críticos -->
<link rel="preconnect" href="https://api.openrouter.ai" />
<link rel="preconnect" href="https://generativelanguage.googleapis.com" />
H. REDUCIR TAREAS LARGAS (TBT de 470ms a <200ms)

Break Up Long Tasks:

text
// Usar setTimeout para dividir tareas largas
function* yieldToMain() {
  return new Promise(resolve => {
    setTimeout(resolve, 0);
  });
}

async function procesarDatosGrandes(data) {
  for (let i = 0; i < data.length; i++) {
    procesarItem(data[i]);
    if (i % 50 === 0) await yieldToMain();
  }
}
Web Workers para Procesamiento Pesado:

text
// Para operaciones pesadas moverlas a Web Workers
const worker = new Worker('/worker.js');
worker.postMessage(heavyData);
worker.onmessage = (e) => {
  console.log('Resultado:', e.data);
};
I. OPTIMIZAR ÁRBOL DE DEPENDENCIAS LCP

text
// Priorizar carga de recursos LCP
// 1. Imagen hero debe estar en HTML estático, no cargada por JS
// 2. No bloquear LCP con JS/CSS no crítico
// 3. Usar fetchpriority="high" en imagen LCP

<img 
  src="/hero.webp"
  fetchpriority="high"
  decoding="async"
  width="1920"
  height="1080"
  alt="Hero"
/>